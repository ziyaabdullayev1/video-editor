ğŸ¯ VÄ°DEO EDÄ°TÃ–R - KESME SÃœRÃœKLEME SÄ°STEMÄ°
=======================================

ğŸ“ SÄ°STEMÄ°N TEMEL YAPISI
------------------------

1. DRAG STATE (SÃ¼rÃ¼kleme Durumu):
   let dragging = null;                    // 'start', 'end' veya null
   let dragState = { 
     lastUpdate: 0,                        // Son gÃ¼ncelleme zamanÄ±
     animFrame: null                       // Animation frame ID'si
   };

2. ZOOM TABANLI PRECÄ°SÄ°ON (Hassasiyet):
   function dragStep() {
     const pps = pxPerSec();               // Pixel per second
     if (pps >= 1000) return 0.01;        // 10ms precision (Ã§ok yakÄ±n zoom)
     if (pps >= 500) return 0.05;         // 50ms precision
     if (pps >= 200) return 0.1;          // 100ms precision
     if (pps >= 100) return 0.2;          // 200ms precision
     return 0.5;                          // 500ms precision (uzak zoom)
   }

ğŸ–±ï¸ MOUSE DOWN EVENTÄ° (SÃ¼rÃ¼kleme BaÅŸlangÄ±cÄ±)
-------------------------------------------

1. BAÅLANGIÃ‡ KURULUMU:
   - scrubbing = true (sÃ¼rÃ¼kleme moduna geÃ§)
   - wasPlaying = !active().paused (oynatma durumunu kaydet)
   - vA.pause(); vB.pause() (videolarÄ± durdur)

2. VÄ°ZUAL DURUM DEÄÄ°ÅÄ°KLÄ°ÄÄ°:
   - tl.classList.add('dragging') (timeline'a dragging sÄ±nÄ±fÄ± ekle)
   - document.body.style.cursor = 'ew-resize' (imleci deÄŸiÅŸtir)
   - document.body.style.userSelect = 'none' (metin seÃ§imini engelle)

3. HANDLE SEÃ‡Ä°MÄ° (Hangi tutamak sÃ¼rÃ¼kleniyor):
   const pick = () => {
     const x = e.clientX - rect.left;
     if(e.target === hStart || e.target.closest('#hStart')) return 'start';
     if(e.target === hEnd || e.target.closest('#hEnd')) return 'end';
     // En yakÄ±n handle'Ä± bul
     const sX = hStart.getBoundingClientRect().left - rect.left;
     const eX = hEnd.getBoundingClientRect().left - rect.left;
     return (Math.abs(x - sX) < Math.abs(x - eX)) ? 'start' : 'end';
   };

ğŸ¯ SMOOTH DRAG FUNCTION (PÃ¼rÃ¼zsÃ¼z SÃ¼rÃ¼kleme)
--------------------------------------------

const setByX = (xpx) => {
  // 1. FPS LÄ°MÄ°TÄ° (120 FPS'e sÄ±nÄ±rla):
  const now = performance.now();
  if (now - dragState.lastUpdate < 8) return;
  dragState.lastUpdate = now;
  
  // 2. HAM POZÄ°SYON HESAPLA:
  let rawEff = xToEff(xpx);  // Pixel'i zaman deÄŸerine Ã§evir
  
  // 3. ZOOM TABANLI PRECÄ°SÄ°ON UYGULA:
  const step = dragStep();
  const precision = Math.min(step, 0.001); // En az 1ms hassasiyet
  const smoothedEff = Math.round(rawEff / precision) * precision;
  
  // 4. MÄ°NÄ°MUM SEÃ‡Ä°M ARALIÄI:
  const minSelection = Math.max(0.01, effSpan() * 0.005); // %0.5 veya 10ms
  
  // 5. POZÄ°SYON GÃœNCELLEME:
  if (dragging === 'start') {
    selEffStart = clamp(smoothedEff, viewStart, selEffEnd - minSelection);
    previewAtEff(selEffStart);  // CanlÄ± Ã¶nizleme
  } else {
    selEffEnd = clamp(smoothedEff, selEffStart + minSelection, viewEnd);
    previewAtEff(selEffEnd);    // CanlÄ± Ã¶nizleme
  }
  
  // 6. UI GÃœNCELLEMESI (Animation Frame ile):
  if (dragState.animFrame) {
    cancelAnimationFrame(dragState.animFrame);
  }
  dragState.animFrame = requestAnimationFrame(() => {
    placeHandles();  // Handle pozisyonlarÄ±nÄ± gÃ¼ncelle
  });
};

ğŸ“ POZÄ°SYON HESAPLAMA SÄ°STEMÄ°
-----------------------------

1. PIXEL â†” ZAMAN DÃ–NÃœÅÃœMÃœ:
   function innerW() { return tl.clientWidth - 16; }  // Ä°Ã§ geniÅŸlik
   function effToX(e) { 
     return 8 + ((e - viewStart) / effSpan()) * innerW(); 
   }
   function xToEff(x) { 
     return clamp(viewStart + ((x-8)/innerW()) * effSpan(), 0, effDuration()); 
   }

2. HANDLE POZÄ°SYONLAMA:
   function placeHandles() {
     const sX = effToX(selEffStart);       // BaÅŸlangÄ±Ã§ X pozisyonu
     const eX = effToX(selEffEnd);         // BitiÅŸ X pozisyonu
     const pct = v => (v / tl.clientWidth * 100) + '%';
     
     hStart.style.left = pct(sX);          // BaÅŸlangÄ±Ã§ handle
     hEnd.style.left = pct(eX);            // BitiÅŸ handle
     cutZone.style.left = pct(sX);         // Kesim bÃ¶lgesi baÅŸlangÄ±cÄ±
     cutZone.style.right = pct(tl.clientWidth - eX);  // Kesim bÃ¶lgesi bitiÅŸi
   }

ğŸ¬ CANLI Ã–NÄ°ZLEME SÄ°STEMÄ°
-------------------------

function previewAtEff(eff) {
  const real = effToReal(eff);             // Efektif zamanÄ± gerÃ§ek zamana Ã§evir
  const A = active(), B = standby();       // Aktif ve bekleyen video katmanlarÄ±
  
  try { A.currentTime = real; } catch {}   // Ana video zamanÄ±nÄ± ayarla
  
  // Sonraki kesim varsa standby video'yu ayarla:
  const nxt = nextCutAfter(real);
  const standbyTarget = nxt ? Math.max(nxt.e, real + (nxt.e - nxt.s)) : real;
  try { B.currentTime = standbyTarget; } catch {}
  
  // UI gÃ¼ncellemeleri:
  isSeeking = true;
  seek.max = effDuration().toFixed(3);
  seek.value = clamp(eff, 0, effDuration()).toFixed(3);
  tCur.textContent = fmtSmart(eff);
}

ğŸ–±ï¸ MOUSE MOVE & UP EVENTLERÄ°
-----------------------------

1. MOUSE MOVE:
   const onMove = (ev) => {
     ev.preventDefault();
     setByX(ev.clientX - rect.left);       // Yeni pozisyonu hesapla
   };

2. MOUSE UP (SÃ¼rÃ¼kleme BitiÅŸi):
   const onUp = () => {
     // Event listener'larÄ± kaldÄ±r:
     window.removeEventListener('mousemove', onMove);
     window.removeEventListener('mouseup', onUp);
     
     // GÃ¶rsel durumu temizle:
     tl.classList.remove('dragging');
     document.body.style.cursor = '';
     document.body.style.userSelect = '';
     
     // Animation frame'i temizle:
     if (dragState.animFrame) {
       cancelAnimationFrame(dragState.animFrame);
       dragState.animFrame = null;
     }
     
     // Final precision ayarlamasÄ±:
     const finalStep = dragStep();
     if (dragging === 'start') {
       selEffStart = Math.round(selEffStart / finalStep) * finalStep;
     } else {
       selEffEnd = Math.round(selEffEnd / finalStep) * finalStep;
     }
     
     // Durumu sÄ±fÄ±rla:
     dragging = null;
     scrubbing = false;
     isSeeking = false;
     
     placeHandles(); // Final pozisyon gÃ¼ncellemesi
     
     // Oynatmaya devam et (eÄŸer Ã¶nceden oynatÄ±lÄ±yorsa):
     if (wasPlaying) {
       active().play();
       standby().play();
     }
   };

ğŸ® TOUCH SUPPORT (Mobil Destek)
-------------------------------

1. TOUCH START:
   tl.addEventListener('touchstart', (e) => {
     if (e.touches.length !== 1) return;
     e.preventDefault();
     
     // Touch event'i mouse event'e dÃ¶nÃ¼ÅŸtÃ¼r:
     const touch = e.touches[0];
     const mouseEvent = new MouseEvent('mousedown', {
       clientX: touch.clientX,
       clientY: touch.clientY,
       bubbles: true
     });
     
     const element = document.elementFromPoint(touch.clientX, touch.clientY);
     if (element) {
       mouseEvent.target = element;
       tl.dispatchEvent(mouseEvent);
     }
   }, { passive: false });

2. TOUCH MOVE & END:
   - Touch event'leri mouse event'lerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r
   - AynÄ± sÃ¼rÃ¼kleme mantÄ±ÄŸÄ± kullanÄ±lÄ±r

ğŸ”§ PERFORMAns OPTÄ°MÄ°ZASYONLARI
------------------------------

1. FPS LÄ°MÄ°TÄ°: 120 FPS (8ms interval)
2. ANIMATION FRAME: requestAnimationFrame ile pÃ¼rÃ¼zsÃ¼z animasyon
3. PRECISION CONTROL: Zoom seviyesine gÃ¶re hassasiyet ayarÄ±
4. DEBOUNCING: Ã‡ok hÄ±zlÄ± gÃ¼ncellemeleri engelle
5. CLAMP FUNCTION: DeÄŸerleri sÄ±nÄ±rlar iÃ§inde tut

Bu sistem sayesinde:
- Pixel-perfect hassasiyet
- PÃ¼rÃ¼zsÃ¼z sÃ¼rÃ¼kleme deneyimi  
- Zoom seviyesine gÃ¶re adaptive precision
- CanlÄ± video Ã¶nizlemesi
- Touch cihaz desteÄŸi
saÄŸlanÄ±r!

